# SQLD 기출문제 모음

### 문제 1
주식별자 없어도 되는 예외는?

1) 기본 엔터티
2) 중심 엔터티
3) 관계 엔터티
4) 행위 엔터티

정답: 3

해설: 관계 엔터티는 두 개 이상의 엔터티로부터 발생하는 관계를 실체화한 엔터티로, 주식별자가 없어도 됩니다.

---

### 문제 2
학생데이터 문제에서 가장 적절한 해결방안은?

1) 학과를 삭제한다
2) 학생 정보를 삭제한다
3) 학과와 학생을 통합한다
4) 학과와 학생을 분리한다

정답: 1

해설: 학과 정보가 중복되어 발생하는 문제를 해결하기 위해서는 학과를 삭제하고 별도의 테이블로 관리하는 것이 적절합니다.

---

### 문제 3
스키마(외부, 개념)에 대한 설명으로 가장 적절한 것은?

1) 개별 사용자 관점의 논리적 스키마를 표현한다
2) 전체 데이터베이스의 통합된 뷰를 제공한다
3) 물리적 저장 구조를 정의한다
4) 특정 DBMS의 특성을 반영한다

정답: 2

해설: 개념 스키마는 조직 전체의 관점에서 데이터베이스의 전체적인 논리 구조를 표현하며, 통합된 뷰를 제공합니다.

---

### 문제 4
개념적 모델링의 특징으로 가장 적절하지 않은 것은?

1) 업무 중심적 관점에서 모델링을 수행한다
2) 데이터베이스 설계 프로세스의 첫 번째 단계이다
3) 추상화 수준이 높아 물리적 설계가 쉽다
4) 현실 세계의 중요한 개념을 구분하여 표현한다

정답: 3

해설: 개념적 모델링은 추상화 수준이 높아 오히려 물리적 설계가 어려울 수 있습니다. 상위 수준의 추상화로 인해 실제 구현 시 더 많은 상세 설계가 필요합니다.

---

### 문제 5
부모 엔터티가 될 수 있는 것은?

1) 기본 엔터티
2) 중심 엔터티
3) 행위 엔터티
4) 관계 엔터티

정답: 1

해설: 기본 엔터티는 독립적으로 생성이 가능하고 다른 엔터티의 부모 역할을 할 수 있는 엔터티입니다.

---

### 문제 6
ERD에서 인스턴스와 속성의 관계를 올바르게 표현한 것은?

1) 인스턴스는 하나의 속성만 가질 수 있다
2) 속성은 여러 개의 값을 가질 수 있다
3) 인스턴스와 속성은 M:M 관계이다
4) 인스턴스는 여러 속성을 가지고, 각 속성은 하나의 값만 가진다

정답: 4

해설: ERD에서 인스턴스와 속성의 관계를 표현할 때, 인스턴스는 여러 속성을 가질 수 있지만 각 속성은 하나의 값만 가질 수 있습니다.

---

### 문제 7
다음 중 외래키(FK)에 대한 설명으로 옳지 않은 것은?

1) 다른 테이블의 기본키를 참조한다
2) 참조 무결성 제약조건의 기본이 된다
3) 내부 식별자로만 사용된다
4) NULL 값을 허용할 수 있다

정답: 3

해설: 외래키(FK)는 내부 식별자로만 사용되는 것이 아니라, 외부 식별자로 사용됩니다.

---

### 문제 8
식별관계와 비식별관계에 대한 설명으로 옳은 것은?

1) 비식별관계는 실선으로 표현한다
2) 식별관계에서는 부모 테이블의 키가 자식의 일반 속성이 된다
3) 식별관계는 실선, 비식별관계는 점선으로 표현한다
4) 비식별관계에서는 반드시 부모 테이블이 존재해야 한다

정답: 3

해설: 식별관계는 실선으로, 비식별관계는 점선으로 표현합니다. 식별관계에서는 부모의 키가 자식의 기본키가 되고, 비식별관계에서는 일반 속성이 됩니다.

---

### 문제 9
교수 / 학생 / 과목 관계에서 정규화 후 추가로 생기는 테이블 수는?

1) 0개
2) 1개
3) 2개
4) 3개

정답: 3

해설: 교수-과목, 학생-과목 관계를 표현하기 위해 2개의 테이블이 추가로 필요합니다.

---

### 문제 10
제1정규형, 제2정규형, 제3정규형에 대한 설명으로 옳은 것은?

1) 제3정규형은 제1정규형과 제2정규형을 만족하지 않아도 된다
2) 제2정규형은 제1정규형을 만족해야 한다
3) 제1정규형은 제2정규형을 만족해야 한다
4) 정규형은 순서와 관계없이 적용할 수 있다

정답: 2

해설: 정규화는 순차적으로 진행되며, 상위 정규형은 하위 정규형의 조건을 모두 만족해야 합니다.

---

### 문제 11
다음 SQL 문의 결과로 옳은 것은?
WHERE NOT (col1 = 1 OR col2 = null)

1) col1이 1이 아니고 col2가 NULL이 아닌 데이터
2) col1이 1이 아니거나 col2가 NULL이 아닌 데이터
3) col1이 1이고 col2가 NULL인 데이터
4) col1이 1이 아닌 데이터

정답: 4

해설: NOT 연산자와 NULL 비교 연산의 특성을 이해해야 합니다.

---

### 문제 12
다음 중 NULL 처리 함수의 결과가 다른 것은?

1) NVL(값, 옵션)
2) COALESCE(값, 옵션)
3) NULLIF(값, 옵션)
4) CASE WHEN 값 IS NOT NULL THEN 값 ELSE 옵션 END

정답: 3

해설: NULLIF는 두 값이 같으면 NULL을 반환하고, 다르면 첫 번째 값을 반환하는 반면, 다른 함수들은 NULL을 다른 값으로 대체하는 기능을 합니다.

---

### 문제 13
RANGE 2 PRECEDING AND 2 FOLLOWING을 사용한 윈도우 함수의 결과값으로 옳은 것은?

1) 현재 행의 앞 2행과 뒤 2행의 합계
2) 현재 행의 앞 2행만의 합계
3) 현재 행의 값에서 -2에서 +2 범위의 값들의 합계
4) 현재 행의 뒤 2행만의 합계

정답: 3

해설: RANGE는 현재 행의 값을 기준으로 지정된 범위 내의 값들을 처리합니다.

---

### 문제 14
계층형 쿼리에서 PRIOR의 위치로 올바른 것은?

1) START WITH PRIOR emp_no = mgr_no
2) CONNECT BY PRIOR emp_no = mgr_no
3) CONNECT BY emp_no = PRIOR mgr_no
4) ORDER SIBLINGS BY PRIOR emp_no

정답: 2

해설: 계층형 쿼리에서 PRIOR는 부모 노드를 지정하는 컬럼 앞에 위치합니다.

---

### 문제 15
NVL 함수를 사용한 금액 계산에서 올바른 것은?

1) NVL(금액1, 0) + NVL(금액2, NULL)
2) NVL(금액1, NULL) + NVL(금액2, 0)
3) NVL(금액1, 0) + NVL(금액2, 0)
4) NVL(금액1, NULL) + NVL(금액2, NULL)

정답: 3

해설: NULL 값을 처리할 때는 0이나 다른 기본값으로 대체하는 것이 안전합니다.

---

### 문제 16
계층형 쿼리에서 순방향과 역방향을 결정하는 것은?

1) START WITH
2) PRIOR
3) CONNECT BY
4) ORDER SIBLINGS BY

정답: 2

해설: PRIOR 키워드의 위치에 따라 순방향과 역방향이 결정됩니다.

---

### 문제 17
트랜잭션의 특성 중 다른 트랜잭션의 영향을 받지 않고 독립적으로 실행되어야 하는 것은?

1) 원자성(Atomicity)
2) 일관성(Consistency)
3) 고립성(Isolation)
4) 지속성(Durability)

정답: 3

해설: 고립성(Isolation)은 트랜잭션이 다른 트랜잭션의 영향을 받지 않고 독립적으로 실행되어야 함을 의미합니다.

---

### 문제 18
서브쿼리에 대한 설명 중 옳지 않은 것은?

1) 서브쿼리는 메인쿼리의 컬럼을 참조할 수 있다
2) 서브쿼리는 괄호로 감싸서 사용한다
3) 서브쿼리의 컬럼을 메인쿼리에서 사용할 수 있다
4) 서브쿼리는 단일 행 또는 복수 행을 반환할 수 있다

정답: 3

해설: 서브쿼리의 컬럼은 메인쿼리에서 직접 사용할 수 없습니다.

---

### 문제 19
RANK 함수의 결과값이 1, 2, 2, 3과 같이 나오게 하려면 어떤 함수를 사용해야 하는가?

1) RANK()
2) DENSE_RANK()
3) ROW_NUMBER()
4) PERCENT_RANK()

정답: 2

해설: DENSE_RANK() 함수는 동일한 값에 대해 같은 순위를 부여하고, 다음 순위는 이전 순위 + 1로 계산합니다.

---

### 문제 20
다음 중 SQL 명령어와 관리 구문 타입의 매칭이 적절하지 않은 것은?

1) SELECT - DML
2) CREATE - DDL
3) GRANT - DCL
4) INSERT - DCL

정답: 4

해설: INSERT는 DML(Data Manipulation Language)에 속하는 명령어입니다.

---

### 문제 21
다음 중 차집합 연산으로 옳은 것은?

1) UNION
2) INTERSECT
3) JOIN
4) EXCEPT

정답: 4

해설: EXCEPT(또는 MINUS)는 첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 뺀 차집합을 반환합니다.

---

### 문제 22
세 번째 문자가 'L'인 단어를 찾기 위한 LIKE 패턴으로 옳은 것은?

1) %L%
2) __L%
3) ___L%
4) %___L%

정답: 2

해설: 언더스코어(_) 두 개와 'L', 그리고 나머지 문자를 나타내는 %를 사용하여 세 번째 위치에 'L'이 오는 패턴을 표현합니다.

---

### 문제 23
다음 테이블에서 COALESCE 함수를 사용한 쿼리의 결과값으로 옳은 것은?
[TAB1]
C1   C2   C3
1    2    3
NULL 2    3
NULL NULL 3

SELECT SUM(COALESCE(C1, C2, C3)) FROM TAB1;

1) 0
2) 1
3) 6
4) 14

정답: 3

해설: COALESCE는 첫 번째 NULL이 아닌 값을 반환합니다. 따라서 1+2+3=6이 됩니다.

---

### 문제 24
SELECT 문장의 실행 순서로 올바른 것은?

1) SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY
2) FROM - SELECT - WHERE - GROUP BY - HAVING - ORDER BY
3) FROM - WHERE - GROUP BY - HAVING - ORDER BY - SELECT
4) FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY

정답: 4

해설: SQL 문장의 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순입니다.

---

### 문제 25
다음 중 AS A와 AS B의 결과값이 서로 다른 것은?

1) COUNT(sal) AS A, SUM(sal) AS B
2) MIN(sal) AS A, MAX(sal) AS B
3) MAX(sal) AS A, MIN(sal) AS B
4) AVG(sal) AS A, SUM(sal)/COUNT(*) AS B

정답: 3

해설: MAX와 MIN은 서로 반대되는 값을 반환하므로 결과가 다릅니다.

---

### 문제 26
카테시안 곱이 발생하는 경우는?

1) 제품과 생산라인을 직접 조인할 때
2) 제품과 생산제품을 조인할 때
3) 생산제품과 생산라인을 조인할 때
4) 모든 테이블을 조인할 때

정답: 1

해설: 제품과 생산라인을 직접적인 관계가 없어 직접 조인하면 카테시안 곱이 발생합니다.

---

### 문제 27
주문을 한 번도 하지 않은 회원을 찾는 SQL문으로 옳은 것은?

1) WHERE NOT EXISTS (SELECT * FROM 주문 WHERE 회원.id = 주문.회원id)
2) WHERE EXISTS (SELECT * FROM 주문 WHERE 회원.id != 주문.회원id)
3) WHERE EXISTS (SELECT * FROM 주문 WHERE 회원.id = 주문.회원id)
4) WHERE NOT EXISTS (SELECT * FROM 주문 WHERE 회원.id != 주문.회원id)

정답: 1

해설: NOT EXISTS를 사용하여 해당 회원의 주문 기록이 없는 경우를 찾을 수 있습니다.

---

### 문제 28
테이블 생성 시 제약조건을 함께 삭제하는 옵션은?

1) CASCADE
2) RESTRICT
3) SET NULL
4) NO ACTION

정답: 1

해설: CASCADE 옵션은 참조하는 제약조건도 함께 삭제합니다.

---

### 문제 29
ROLE에 대한 설명으로 옳은 것은?

1) REVOKE로 부여하고 GRANT로 회수한다
2) GRANT로 부여하고 REVOKE로 회수한다
3) CREATE로 부여하고 DROP으로 회수한다
4) ALTER로 부여하고 DROP으로 회수한다

정답: 2

해설: ROLE은 GRANT 명령어로 권한을 부여하고, REVOKE 명령어로 권한을 회수합니다.

---

### 문제 30
테이블 생성 후 복제(CTAS)에서 제약조건 적용 중 옳은 것은?

1) 프라이머리 키(PK)가 복제되지 않는다
2) NOT NULL 조건이 적용되지 않는다
3) CHECK 제약조건이 적용된다
4) DEFAULT 값이 적용된다

정답: 1

해설: CTAS(Create Table As Select)를 사용할 때 NOT NULL 제약조건만 복제되고, 기본키를 포함한 다른 제약조건은 복제되지 않습니다.

---

### 문제 31
총 월급이 2000 이상인 부서를 찾는 SQL문으로 옳은 것은?

1) CASE WHEN SUM(sal) >= 2000 THEN dept_no END
2) CASE WHEN SUM(sal) >= 2000 THEN dept_no ELSE 0 END
3) CASE WHEN SUM(sal) >= 2000 THEN dept_no ELSE '' END
4) CASE WHEN SUM(sal) >= 2000 THEN dept_no ELSE NULL END

정답: 4

해설: CASE문에서 조건에 맞지 않는 경우 NULL을 반환하는 것이 가장 안전한 방법입니다.

---

### 문제 32
A 결과와 B 결과가 다른 것은?

1) COUNT(*) AS A, COUNT(1) AS B
2) SUM(sal) AS A, SUM(DISTINCT sal) AS B
3) AVG(sal) AS A, SUM(sal)/COUNT(*) AS B
4) MAX(sal) AS A, MIN(sal) AS B

정답: 2

해설: SUM(sal)은 모든 값의 합계를, SUM(DISTINCT sal)은 중복을 제거한 값들의 합계를 반환합니다.

---

### 문제 33
SQL의 특징이 아닌 것은?

1) 절차적(Procedural)
2) 구조적(Structured)
3) 집합적(Set-based)
4) 선언적(Declarative)

정답: 1

해설: SQL은 비절차적(Non-procedural) 언어입니다. 절차적이지 않고 선언적인 특성을 가집니다.

---

### 문제 34
MAX, MIN과 UNION을 사용한 쿼리의 결과값은?

1) 8925
2) 8952
3) 9285
4) 9528

정답: 1

해설: MAX와 MIN 값을 UNION으로 합치면 중복이 제거되고 정렬된 결과가 반환됩니다.

---

### 문제 35
ROLLUP 함수 사용 시 올바른 문법은?

1) ROLLUP(a, b)
2) ROLLUP((a), (b))
3) ROLLUP((a, b))
4) ROLLUP(a), ROLLUP(b)

정답: 3

해설: 중첩 괄호를 사용한 ROLLUP((a, b))는 a와 b를 하나의 그룹으로 처리합니다.

---

### 문제 36
NULL이 포함된 컬럼에 대한 설명으로 옳은 것은?

1) AVG(컬럼)과 AVG(NVL(컬럼,0))의 결과는 항상 같다
2) COUNT(컬럼)과 COUNT(*)의 결과는 항상 같다
3) SUM(컬럼)과 SUM(NVL(컬럼,0))의 결과는 항상 같다
4) AVG(컬럼)과 AVG(NVL(컬럼,0))의 결과는 다를 수 있다

정답: 4

해설: NULL을 0으로 대체하면 평균값이 달라질 수 있습니다.

---

### 문제 37
NATURAL JOIN에 대한 설명으로 옳지 않은 것은?

1) USING 절을 사용할 수 있다
2) ON 절을 사용할 수 있다
3) 같은 이름의 컬럼을 자동으로 조인한다
4) 조인 조건을 명시적으로 지정할 필요가 없다

정답: 2

해설: NATURAL JOIN은 ON 절을 사용할 수 없습니다. 자동으로 같은 이름의 컬럼을 조인합니다.

---

### 문제 38
CHECK 제약조건에 대한 설명으로 옳지 않은 것은?

1) 하나의 테이블에 여러 개의 CHECK 제약조건을 정의할 수 있다
2) 컬럼값에 대한 제약조건을 정의할 수 있다
3) TRUE 또는 FALSE로 평가되어야 한다
4) 다른 테이블의 값을 참조할 수 있다

정답: 4

해설: CHECK 제약조건은 현재 테이블의 컬럼만을 사용할 수 있으며, 다른 테이블의 값은 참조할 수 없습니다.

---

### 문제 39
다음 중 GROUP BY 절에서 사용할 수 있는 함수는?

1) RANK
2) CUBE
3) ROW_NUMBER
4) DENSE_RANK

정답: 2

해설: CUBE는 GROUP BY 절에서 사용할 수 있는 그룹화 함수입니다.

---

### 문제 40
WHERE 절에 NOT (col <= 2)인 경우, 결과에 포함되는 것은?

1) NULL만 포함
2) 3 이상의 값만 포함
3) NULL과 3 이상의 값 포함
4) 2 이하의 값만 포함

정답: 3

해설: NOT (col <= 2)는 col > 2 또는 col이 NULL인 경우를 포함합니다.

---

### 문제 41
조인 유형별 결과가 다른 것은?

1) INNER JOIN
2) LEFT OUTER JOIN
3) RIGHT OUTER JOIN
4) CROSS JOIN

정답: 4

해설: CROSS JOIN은 두 테이블의 모든 행을 조합하는 카테시안 곱을 생성하므로 다른 조인과 결과가 다릅니다.

---

### 문제 42
제품, 생산제품, 생산라인 엔터티 간의 관계에서 발생하는 문제는?

1) 제품과 생산라인 직접 조인 시 카테시안 곱 발생
2) 제품과 생산제품 조인 시 중복 발생
3) 생산제품과 생산라인 조인 시 데이터 손실
4) 모든 테이블 조인 시 성능 저하

정답: 1

해설: 제품과 생산라인은 직접적인 관계가 없어 직접 조인하면 카테시안 곱이 발생합니다.

---

### 문제 43
NULL 처리 함수의 결과가 다른 것은?

1) NVL(NULL, 0)
2) COALESCE(NULL, 0)
3) NULLIF(0, 0)
4) CASE WHEN NULL IS NULL THEN 0 END

정답: 3

해설: NULLIF(0, 0)는 두 값이 같으므로 NULL을 반환하지만, 다른 함수들은 0을 반환합니다.

---

### 문제 44
NULL이 포함된 컬럼에 대해 다음 중 결과가 다른 것은?

1) COUNT(*)
2) COUNT(col)
3) COUNT(NVL(col, 0))
4) AVG(NVL(col, 0))

정답: 4

해설: AVG 함수는 NULL을 0으로 대체할 경우 평균값이 달라질 수 있습니다.

---

### 문제 45
중복을 제거하는 키워드로 올바른 것은?

1) UNIQUE
2) DISTINCT
3) DIFFERENT
4) NODUPE

정답: 2

해설: DISTINCT는 SELECT 문에서 중복된 행을 제거하는 키워드입니다.

---

### 문제 46
MERGE 문의 올바른 구문 순서는?

1) MERGE - INSERT - UPDATE
2) MERGE - UPDATE - DELETE
3) MERGE - UPDATE - INSERT
4) MERGE - DELETE - INSERT

정답: 3

해설: MERGE 문의 기본 구문 순서는 MERGE - UPDATE - INSERT입니다.

---

### 문제 47
날짜 형식 'YYYYMMDDHH24MISS'의 결과로 올바른 것은?

1) 20240301235959
2) 2024-03-01 23:59:59
3) 24/03/01 23:59:59
4) 20240301 235959

정답: 1

해설: 'YYYYMMDDHH24MISS' 형식은 구분자 없이 연속된 숫자로 표현됩니다.

---

### 문제 48
계층형 쿼리에서 PRIOR가 들어갈 위치는?

1) START WITH 절
2) CONNECT BY 절의 조건 앞
3) ORDER SIBLINGS BY 절
4) WHERE 절

정답: 2

해설: PRIOR는 CONNECT BY 절에서 부모-자식 관계를 지정할 때 사용됩니다.

---

### 문제 49
부서 테이블의 행을 삭제할 때 사원 테이블의 행도 함께 삭제하는 제약조건은?

1) RESTRICT
2) SET NULL
3) ON DELETE CASCADE
4) NO ACTION

정답: 3

해설: ON DELETE CASCADE는 부모 테이블의 행이 삭제될 때 참조하는 자식 테이블의 행도 함께 삭제합니다.

---

### 문제 50
기본키(Primary Key)에 대한 설명으로 옳지 않은 것은?

1) 한 테이블에 여러 개의 기본키를 지정할 수 있다
2) NULL 값을 가질 수 없다
3) 중복된 값을 가질 수 없다
4) 테이블당 하나만 지정할 수 있다

정답: 1

해설: 기본키는 테이블당 하나만 지정할 수 있으며, 여러 개의 컬럼으로 구성될 수는 있지만 여러 개의 기본키를 가질 수는 없습니다.

---

### 문제 51
내부 스키마에 대한 설명으로 적절한 것은?

1) 개별 사용자 관점의 논리적 스키마를 표현한다
2) 물리적 저장구조를 정의한다
3) 전체 데이터베이스의 통합된 뷰를 제공한다
4) 특정 DBMS의 특성을 반영하지 않는다

정답: 2

해설: 내부 스키마는 데이터베이스가 물리적으로 저장된 형식을 표현하며, 물리적 장치에서 데이터가 실제적으로 저장되는 방법을 표현하는 스키마입니다.

---

### 문제 52
엔터티명에 대한 설명으로 적절한 것은?

1) 약어를 사용하는 것이 좋다
2) 복수 명사를 사용한다
3) 현업 업무에서 사용하는 용어를 사용한다
4) 엔터티 생성 의미와 관계없이 이름을 부여한다

정답: 3

해설: 엔터티를 명명하는 일반적인 기준은 현업 업무에서 사용하는 용어를 사용하고, 약어를 사용하지 않으며, 단수 명사를 사용하는 것입니다.

---

### 문제 53
계층형 모델에 대한 설명으로 적절한 것은?

1) 개체간의 관계가 망형 구조이다
2) 개체간의 관계가 1:M 구조이다
3) 개체간의 관계가 M:N 구조이다
4) 개체간의 관계가 1:1 구조이다

정답: 2

해설: 계층형 모델은 트리 구조를 가지며, 개체간의 관계가 1:M(일대다) 구조입니다.

---

### 문제 54
DENSE_RANK 함수의 특징으로 적절한 것은?

1) 동일한 값에 대해 서로 다른 순위를 부여한다
2) 동일한 값에 대해 같은 순위를 부여하고 건너뛴다
3) 동일한 값에 대해 같은 순위를 부여하고 순차적으로 증가한다
4) 순위를 백분율로 표시한다

정답: 3

해설: DENSE_RANK는 동일한 값에 대해 같은 순위를 부여하고, 다음 순위는 이전 순위 + 1로 순차적으로 증가합니다. 예: 1,2,2,3,4...

---

### 문제 55
ROLLUP과 일반 컬럼을 함께 사용할 때의 결과로 적절한 것은?

1) GROUP BY ROLLUP(col1), col1은 GROUP BY col1과 동일하다
2) GROUP BY ROLLUP(col1), col1은 전체 합계를 포함한다
3) GROUP BY ROLLUP(col1), col1은 부분 합계만 계산한다
4) GROUP BY ROLLUP(col1), col1은 에러가 발생한다

정답: 1

해설: GROUP BY ROLLUP(col1), col1은 실제로 GROUP BY col1과 동일한 결과를 반환합니다. ROLLUP의 효과가 일반 컬럼에 의해 상쇄됩니다.

---

### 문제 56
BETWEEN 조건과 비교 연산자의 차이점으로 적절한 것은?

1) BETWEEN은 경계값을 포함하지 않는다
2) BETWEEN은 경계값을 포함한다
3) BETWEEN은 NULL 값을 처리할 수 없다
4) BETWEEN은 날짜형 데이터에만 사용할 수 있다

정답: 2

해설: BETWEEN A AND B는 A <= x <= B와 동일하며, 경계값 A와 B를 포함합니다.

---

### 문제 57
IN 절에서 서브쿼리 사용 시 주의사항으로 적절한 것은?

1) 서브쿼리는 단일 행만 반환해야 한다
2) 서브쿼리는 단일 컬럼만 반환해야 한다
3) 서브쿼리는 ORDER BY를 사용할 수 없다
4) 서브쿼리는 GROUP BY를 사용할 수 없다

정답: 2

해설: IN 절에서 사용되는 서브쿼리는 단일 컬럼만 반환해야 합니다. 여러 행을 반환할 수 있지만, 컬럼은 하나여야 합니다.

---

### 문제 58
참조 무결성을 위반하는 경우는?

1) 기본키에 NULL 값이 입력된 경우
2) 외래키가 참조하는 기본키 값이 존재하지 않는 경우
3) 기본키가 중복된 값을 가지는 경우
4) CHECK 제약조건을 위반한 경우

정답: 2

해설: 참조 무결성은 외래키가 참조하는 기본키 값이 반드시 존재해야 함을 의미합니다. 존재하지 않는 값을 참조하면 참조 무결성이 위반됩니다.

---

### 문제 59
LIKE 연산자에서 '_'와 '%'의 차이점으로 적절한 것은?

1) '_'는 정확히 한 문자, '%'는 0개 이상의 문자를 의미한다
2) '_'는 숫자만 매칭, '%'는 문자만 매칭한다
3) '_'는 문자만 매칭, '%'는 숫자만 매칭한다
4) '_'와 '%'는 동일한 의미이다

정답: 1

해설: LIKE 연산자에서 '_'는 정확히 한 문자를 의미하고, '%'는 0개 이상의 임의의 문자를 의미합니다.

---

### 문제 60
NULL 값에 대한 설명으로 적절하지 않은 것은?

1) NULL과 NULL의 비교 결과는 알 수 없다
2) NULL과 숫자의 비교 결과는 알 수 없다
3) NULL은 0과 같다
4) NULL은 빈 문자열과 다르다

정답: 3

해설: NULL은 0이나 빈 문자열과 다른 '알 수 없는 값'을 의미합니다. NULL과의 모든 비교 연산은 UNKNOWN을 반환합니다.